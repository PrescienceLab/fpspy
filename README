FPSpy Tool
==========

Copyright (c) 2017 Peter A. Dinda  Please see LICENSE file.

This is a tool for floating point exception interception and
statistics gathering that can run underneath existing, unmodified
binaries.

The initial version of FPSpy is documented in

P. Dinda, A. Bernat, C. Hetland, Spying on the Floating Point Behavior
of Existing, Unmodifed Scientific Applications, Proceedings of the
29th ACM Symposium on High-performance Parallel and Distributed
Computing (HPDC 2020), June, 2020.


You can also see the comments in src/fpspy.c for some details of how
this works and what it illustrates.

This version includes architecture independence, with support for
x64, arm64 (for machines with floating point traps, which are
optional on ARM), and riscv64 (for machines with our specialized
support for floating point traps and pipelined precise exceptions).


Architecture Selection
----------------------

Uncomment one of the following in Makefile:

ARCH=x64
#ARCH=arm64
#ARCH=riscv64

If you are doing cross-compilation, please also configure
PREFIX accordingly.  PREFIX will be prepended to all build tool
names.

Also source the relevant environment variable:

$ source ./ENV.x64


Configuration
-------------

fpspy/include/config.h contains configuration variables.
Comments are provided in the file.   Probably of most note
is CONFIG_TRAP_SHORT_CIRCUITING, which includes support
for the x64 kernel module (if it is available on your kernel).
and CONFIG_NO_DEBUG_OUTPUT which disables chatter.


Kernel Module (optional x64 feature)
------------------------------------

If you wish to use the kernel module on x64 (which considerably lowers
the cost of floating point trap delivery to FPSpy), you will need to
compile that next and insert it.  To do so, consult
kernel/x64/README.md


Building and Testing
--------------------

Make sure you have sourced the relevant ENV file and modified the Makefile
to select your target architecture.

To build:

   make


To test:

   make test

You should now see a number of files with the suffix ".fpemon".   These
are output traces captured from the test_fpspy.c program under various
configurations.  See the Output and Analysis Scripts section for more
information on how to decode these.


Running (simple)
----------------

If you've built FPSpy successfully, and sourced the relevant ENV file,
you should now have a script on your path that provides a simple way to
use FPSpy.   Suppose the program you want to run FPSpy under normally
run as ./PROGRAM.  Then:

   fpspy --aggregate ./PROGRAM

will run FPSpy under it in aggregate mode, and

   fpspy --individual ./PROGRAM

will run FPSpy under it in individual mode.   Aggregate mode
will capture whether any monitored FP event occurs at least once during
the run, while individual mode will capture each instruction
that causes a monitored FP event.


Running (more details)
----------------------

The fpspy script is a thin veneer on top of an LD_PRELOAD library
model with configuration by environment variables.

You generally want your environment configured as follows:

   export PATH=$FPSPY_DIR/bin/$ARCH:$FPSPY_DIR/scripts:$PATH

The code has two modes of operation:

- Aggregate mode simply captures the floating point exception state
  at the beginning and end of the program.  Since the exception state
  is sticky, this will let us know if the program had 1 or more
  occurances of each of the possible exceptions
- Individual mode captures individual floating point exceptions,
  emulating the instructions that cause them.

The code can be run against a dynamically linked binary which crosses
the shared library boundary for the fe* library calls, which
manipulate the FPU behavior, and for the signal and sigaction system
calls.

To run against a binary:

LD_PRELOAD=fpspy.so [FPSPY_MODE=<mode>] [FPSPY_AGGRESSIVE=<yes|no>] exec.exe

The modes are "aggregate" and "individual" as noted above.   If no
mode is given, aggregate mode is assumed.

Generally, FPSpy gets out of the way if the executable itself
attempts to manipulate the FPU signaling state via the fe* and
signal/sigaction system calls.  By default, it is very sensitive to
this. If FPSPY_AGGRESSIVE is set, then it is less sensitive, which means
that more can be captured, but the execution is more likely to be
broken.

Additional environment variables

FPSPY_DISABLE_PTHREADS=yes    (or DISABLE_PTHREADS=yes)
   Do not trace newly created pthreads
   You will also want to set this for any application which
   does not dynamically link the pthread library.  Otherwise startup
   will fail when attempting to shim non-existent pthread functions.

FPSPY_MAXCOUNT=k
   means that only the first k exceptions will be recorded
   this only affects individual mode
   k=-1 means that there is no limit to how many exceptions
   will be recorded.  By default, k is about 64,000.

FPSPY_SAMPLE=k
   means that only every kth exception will be recorded
   this only affects individual mode

FPSPY_EXCEPT_LIST=list
   means that only the listed exceptions will be intercepted
   this only affects individual mode
   the comma-delimited list can include:
        invalid (NAN)
	denorm
	divide (divide by zero)
	overflow
	underflow
	precision (rounding)

FPSPY_POISSON=A:B
   means that Poisson sampling will be used with the ON period
   chosen from an exponential random distro with mean A usec
   and OFF period chosen from an exponential distro with mean
   B seconds.

Time-based sampling and poisson sampling model

FPSPY_SEED=n
   means the internal random number generator for sampling
   is seeded with value n

FPSPY_TIMER=real|virtual|prof  (default real)

virtual timer means by instructions, real timer means by real-time
That is, with FPSPY_POISSON=A:B, and FPSPY_TIMER=virtual, A and B are
interpretted as time spent awake, instead of time spent.   prof timer
is virtual time in both kernel and user space, and using a signal
the application is unlikely to be using.

FPSPY_KICKSTART=y|n  (default n)

If set to y, then FPSPY does not start on the initial process
until a SIGTRAP is delivered externally.   Otherwise, it starts immediately.
This is useful under certain scenarios such as fuzzing where
an external tool can determine a region of interest.

FPSPY_ABORT=y|n  (default n)

If enabled, FPSPY will crash the program with SIGABRT on the first
FPE caught at runtime. Especially useful for fuzzing.

FPSPY_LOG_LEVEL=0|1|2  (default 2)

If set to 0, DEBUG statements will be disabled, and no monitor file (*.fpemon)
will be created. If set to 1, DEBUG statements will be disabled, and a
monitor file will be created. If set to 2, all DEBUG statements will be
enabled, and a monitor file will be created.

For getting a sense of how FPSPY_POISSON operates, you cano
also run:

make test_sleepy  (real time)

or

make test_dopey (virtual or profile time)

FPSPY_KERNEL=y|n  (default n)

Attempt to use kernel support to make FP traps faster.
This is the same support as in FPVM and uses the same kernel module

Forced changes in floating point execution environment

FPSPY_FORCE_ROUNDING=positive|negative|zero|nearest[;daz][;ftz]

This forces rounding to operate in the noted way (IEEE default is nearest).
If daz is included, this means all denorms are treated as zeros [Intel specific]
if ftz is included, this means all denorms are rounded to zeros [Intel specific]

To get a sense of how FPSPY_FORCE_ROUNDING operates, you can
also run:

make test_rounding


Output and Analysis Scripts
---------------------------

FPSpy produces a trace for each thread.

In aggregate mode, a trace is short, simple, user-readable file which
is self-explanatory.

In individual mode, a trace is a binary format file which may be huge.
We provide tools to display and analyze such traces.

in includ and src:

libtrace.h / libtrace.c   -> trace access from C via memory mapping
                             (trace shows up as a giant array of structs)

trace_print.c             -> example use (just prints file in human-readable format)


In scripts:

parse_individual.pl       -> trace_print in perl

analyze_individual.pl     -> create report from trace

extrace_fp_event_timestamps.pl -> create time series from trace

disassem_instr.pl         -> disassemble instruction for x64, arm64, and riscv64
